---
layout:     post
title:      awing 模板改写
subtitle:   
date:       2021-09-08
author:     953max
header-img: 
catalog: 	 true
tags:
    - acwing
    - 模板1
---
### 快速排序
## 快排
注意只能用j来区分，因为取值范围为[i,j),不包含j-1。
```java
void quicksort(int[] arr,int left,int right){
    if(left >= right) return;
    int X = arr[(left+right)>>1],i = left-1,j = right+1;
    while(i < j){
       do i++ while(arr[i] < X);
       do j-- while(arr[j] > X);
       if(i < j) swap(arr,i,j);
    }
    quicksort(arr,left,j);
    quicksort(arr,j+1,right);
}
```
## 快选
```java
int quickSelect(int[] arr,int left,int right,int k){
    if(left >= right) return arr[k];
    int X = arr[(left+right)>>1],i = left-1,j = right+1;
    while(i < j){
       do i++ while(arr[i] < X>);
       do j-- while(arr[j] > X);
       if(i < j) swap(arr,i,j);
    }
    if(k <= j)return quickSelect(arr,left,j);
    else quickSelect(arr,j+1,right);
}
```
### 归并排序
## 归排
```java
void mergeSort(int[] arr,int l,int r){
        if(l >= r) return;
        int mid = (l + r) >> 1;
        mergeSort(arr,l,mid);
        mergeSort(arr,mid+1,r);
        int[] tmp = new int[r-l+1];
        int i = l,j = mid+1,pos = 0;
        while(i <= mid && j <= r){
            if(arr[i] <= arr[j]) tmp[pos++] = arr[i++];//保持原顺序
            else tmp[pos++] = arr[j++];
        }
        while(i <= mid) tmp[pos++] = arr[i++];
        while(j <= r) tmp[pos++] = arr[j++];
        for(int k = 0;k < tmp.length;k++){
            arr[l+k] = tmp[k];
        }
        return;
    }
```
## 逆序对
```java
int count = 0;
void mergeSort(int[] arr,int l,int r){
        if(l >= r) return;
        int mid = (l + r) >> 1;
        mergeSort(arr,l,mid);
        mergeSort(arr,mid+1,r);
        int[] tmp = new int[r-l+1];
        int i = l,j = mid+1,pos = 0;
        while(i <= mid && j <= r){
            if(arr[i] < arr[j]) {
                count++;
                tmp[pos++] = arr[i++];
            }
            else tmp[pos++] = arr[j++];
        }
        while(i <= mid) tmp[pos++] = arr[i++];
        while(j <= r) tmp[pos++] = arr[j++];
        for(int k = 0;k < tmp.length;k++){
            arr[l+k] = tmp[k];
        }
        return;
    }
```
### 二分
## 整数二分
```java
//取整数范围是[l,mid][mid+1,r];
 int lower_bound(int[] arr,int k){
        int left = 0,right = arr.length-1, mid = 0;
        while(left < right){
            mid = left + right >> 1;
            if(check(mid)){
                right = mid;
            }else{
                left = mid+1;
            }
        }
        return arr[left] == k ? left:-1;
}
//取整数范围是[l,mid)[mid,r];
int ceil_bound(int[] arr,int k){
        int left = 0,right = arr.length-1;
        while(left < right){
            int mid = left+right+1 >> 1;
            if(check(mid)){
                left = mid;
            }else{
                right = mid-1;
            }
        }
        return arr[right] == k ? right:-1;
    }
```
## 浮点数二分
```java
//有精度所以不用预处理
double binarysearch(double[] arr){
    while(left < right){
        int mid = left+right >> 1;
        if(check(mid)){
            left = mid;
        }else{
            right = mid;
        }
    }
    return 
}
```
### 前缀和
## 一维前缀和
```java
int (int[] arr,int l,int r){
    int[] sum = new int[arr.length];
    for(int i = 0;i < arr.length;i++){
        sum[i] = arr[i]+sum[i-1];
    }
    //find l到r的和
    return sum[r]-sum[l-1];
}
```
## 二维前缀和
```java
int(int[][] arr,int x1,int y1,int x2,int y2){
    // 以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
    // S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
    return S[x2,y2]-S[x1-1,y2]-S[x2,y1-1]+S[x1-1,y1-1];
}
```
### 差分
## 区间和
```java
void insert (int[] b,int l,int r,int val){
     //差分操作
     b[l] += val;
     b[r+1] -= val;
}
int (int[] arr,int l,int r,int val){
    //用前缀和和差分得出区间和s[l,r]
    int[] b = arr[i]-arr[i-1]//i 从 1开始
    insert(b,l,r,val);
    for(int i = 1;i < len;i++){
        arr[i] = b[i]+arr[i-1];
        s[i] = a[i]+s[i-1];
    }
    return s[r]-s[l-1];

}
```
## 二维差分
```java
```
